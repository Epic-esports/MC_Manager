<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Minecraft Server Manager - Admin</title>

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

<style>
:root{
  --bg:#070A0B;
  --panel: rgba(18, 20, 23, 0.72);
  --panel2: rgba(12, 14, 16, 0.78);
  --solid:#0E1114;
  --border: rgba(255,255,255,0.08);
  --borderStrong: rgba(255,255,255,0.14);
  --text:#EAF7F1;
  --muted: rgba(234,247,241,0.72);
  --muted2: rgba(234,247,241,0.55);
  --green:#00FF9C;
  --cyan:#00CCFF;
  --amber:#FFCC66;
  --red:#FF5A5A;
  --shadow: 0 24px 80px rgba(0,0,0,.60);
  --ring: 0 0 0 4px rgba(0,255,156,0.18);
  --radius: 18px;
  --radiusSm: 14px;
}

*{ box-sizing:border-box; }
html,body{ height:100%; }
body{
  margin:0;
  font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  color: var(--text);
  background:
    radial-gradient(1000px 600px at 15% 10%, rgba(0,255,156,0.14), transparent 60%),
    radial-gradient(900px 600px at 85% 30%, rgba(0,204,255,0.10), transparent 65%),
    radial-gradient(900px 700px at 50% 120%, rgba(0,255,156,0.08), transparent 60%),
    linear-gradient(180deg, #050708 0%, #070A0B 50%, #050708 100%);
  overflow-x:hidden;
}

/* subtle animated grid */
.grid{
  position:fixed; inset:-2px;
  background:
    linear-gradient(rgba(255,255,255,0.06) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,0.06) 1px, transparent 1px);
  background-size: 56px 56px;
  opacity: 0.10;
  mask-image: radial-gradient(60% 50% at 50% 25%, black 40%, transparent 70%);
  pointer-events:none;
  animation: gridDrift 12s linear infinite;
}
@keyframes gridDrift{ from{ transform: translate3d(0,0,0);} to{ transform: translate3d(-56px,-56px,0);} }

/* floating blobs */
.blob{
  position:fixed;
  width: 560px; height: 560px;
  border-radius: 999px;
  filter: blur(70px);
  opacity: .22;
  pointer-events:none;
  mix-blend-mode: screen;
  animation: floaty 10s ease-in-out infinite;
}
.blob.a{ left:-180px; top:-200px; background: radial-gradient(circle at 30% 30%, rgba(0,255,156,0.95), transparent 60%); }
.blob.b{ right:-240px; top:120px; background: radial-gradient(circle at 30% 30%, rgba(0,204,255,0.95), transparent 60%); animation-delay:-2s; }
.blob.c{ left:20%; bottom:-300px; background: radial-gradient(circle at 30% 30%, rgba(0,255,156,0.55), transparent 60%); animation-delay:-4s; }
@keyframes floaty{ 0%,100%{ transform: translate3d(0,0,0) scale(1);} 50%{ transform: translate3d(0,24px,0) scale(1.03);} }

/* layout */
.container{
  width: min(1250px, 94vw);
  margin: 18px auto 22px;
  position:relative;
  z-index:1;
}

.header{
  position: sticky;
  top: 0;
  z-index: 10;
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  background: rgba(10,12,14,0.55);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  padding: 14px 16px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 12px;
}

.brand{
  display:flex;
  align-items:center;
  gap: 12px;
  min-width: 260px;
}

.header-logo{
  width: 42px;
  height: 42px;
  border-radius: 14px;
  object-fit: cover;
  background: #0c0e10;
  border: 1px solid rgba(255,255,255,0.14);
  box-shadow:
    0 0 0 1px rgba(0,0,0,0.35) inset,
    0 12px 28px rgba(0,255,156,0.10);
}

.titleWrap{ display:flex; flex-direction:column; gap:2px; }
.title{
  margin:0;
  font-weight: 800;
  letter-spacing: -0.3px;
  font-size: 16px;
}
.subtitle{
  margin:0;
  color: var(--muted);
  font-size: 12px;
}

.headerRight{
  display:flex;
  align-items:center;
  gap: 10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}

.pill{
  display:flex;
  align-items:center;
  gap: 8px;
  padding: 10px 12px;
  border-radius: 999px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.03);
  color: rgba(234,247,241,0.86);
  font-size: 12px;
  user-select:none;
}
.pill strong{ color: rgba(234,247,241,0.95); font-weight: 700; }

.pill .dot{
  width: 8px; height: 8px; border-radius: 999px;
  background: rgba(234,247,241,0.25);
  box-shadow: 0 0 0 4px rgba(234,247,241,0.06);
}
.pill.good .dot{ background: var(--green); box-shadow: 0 0 0 4px rgba(0,255,156,0.12); }
.pill.bad .dot{ background: var(--red); box-shadow: 0 0 0 4px rgba(255,90,90,0.12); }
.pill.warn .dot{ background: var(--amber); box-shadow: 0 0 0 4px rgba(255,204,102,0.12); }

/* new info bar */
.infoBar{
  margin-top: 14px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: var(--shadow);
  padding: 12px;
  display:grid;
  grid-template-columns: 1.15fr 1fr 1fr;
  gap: 12px;
}

.card{
  border: 1px solid var(--border);
  border-radius: var(--radiusSm);
  background: rgba(10,12,14,0.48);
  padding: 12px;
  position:relative;
  overflow:hidden;
}
.card::before{
  content:"";
  position:absolute;
  inset:-2px;
  background:
    radial-gradient(600px 180px at 15% 0%, rgba(0,255,156,0.10), transparent 55%),
    radial-gradient(520px 220px at 95% 10%, rgba(0,204,255,0.08), transparent 55%);
  pointer-events:none;
  opacity: 0.8;
}
.cardInner{ position:relative; z-index:1; }

.cardTop{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap: 10px;
}

.cardTitle{
  font-size: 12px;
  color: var(--muted);
  letter-spacing: 0.2px;
}

.cardValue{
  margin-top: 6px;
  font-size: 18px;
  font-weight: 800;
  letter-spacing: -0.3px;
}

.valueOnline{ color: var(--green); }
.valueOffline{ color: var(--red); }
.valueWarn{ color: var(--amber); }

.small{
  margin-top: 2px;
  font-size: 12px;
  color: var(--muted2);
}

/* toggle switch */
.switch{
  display:inline-flex;
  align-items:center;
  gap: 10px;
}

.toggle{
  width: 54px;
  height: 32px;
  border-radius: 999px;
  border: 1px solid var(--borderStrong);
  background: rgba(255,255,255,0.04);
  position:relative;
  cursor:pointer;
  transition: .18s ease;
}

.toggle::after{
  content:"";
  width: 24px;
  height: 24px;
  border-radius: 999px;
  position:absolute;
  top: 50%;
  left: 4px;
  transform: translateY(-50%);
  background: rgba(234,247,241,0.75);
  box-shadow: 0 10px 20px rgba(0,0,0,0.35);
  transition: .18s ease;
}

.toggle.on{
  border-color: rgba(0,255,156,0.45);
  background: rgba(0,255,156,0.14);
}
.toggle.on::after{
  left: 26px;
  background: var(--green);
  box-shadow: 0 0 0 4px rgba(0,255,156,0.12), 0 12px 22px rgba(0,255,156,0.10);
}

.toggle.disabled{
  opacity: 0.55;
  cursor: not-allowed;
  pointer-events: none;
}

.toggleLabel{
  font-size: 12px;
  color: rgba(234,247,241,0.85);
  font-weight: 700;
  letter-spacing: 0.2px;
}

/* status row (players/ram etc) */
.statusPanel{
  margin-top: 14px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: var(--shadow);
  padding: 12px;
  display:grid;
  grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
  gap: 12px;
}

.stat{
  border-radius: var(--radiusSm);
  border: 1px solid var(--border);
  background: rgba(10,12,14,0.48);
  padding: 12px;
  position:relative;
  overflow:hidden;
}

.stat::before{
  content:"";
  position:absolute;
  inset:-2px;
  background:
    radial-gradient(520px 180px at 15% 0%, rgba(0,255,156,0.08), transparent 55%),
    radial-gradient(480px 180px at 95% 0%, rgba(0,204,255,0.06), transparent 55%);
  opacity:0.75;
  pointer-events:none;
}

.statInner{ position:relative; z-index:1; }

.statLabel{ font-size: 12px; color: var(--muted); }
.statValue{ margin-top: 6px; font-size: 18px; font-weight: 800; letter-spacing: -0.3px; }

.playerNames{
  margin-top: 8px;
  display:flex;
  flex-wrap:wrap;
  gap: 6px;
}

.playerChip{
  font-size: 11px;
  padding: 6px 8px;
  border-radius: 999px;
  border: 1px solid rgba(0,255,156,0.22);
  background: rgba(0,255,156,0.06);
  color: rgba(234,247,241,0.88);
}
.playerEmpty{ color: var(--muted2); }

.ramBar{
  margin-top: 8px;
  width: 100%;
  height: 12px;
  border-radius: 999px;
  background: rgba(255,255,255,0.06);
  overflow:hidden;
  border: 1px solid rgba(255,255,255,0.08);
}
.ramFill{
  height:100%;
  width:0%;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(0,255,156,0.95), rgba(0,204,255,0.65));
  transition: width .35s ease;
}

/* admin config panel */
.adminPanel{
  margin-top: 14px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: var(--shadow);
  padding: 12px;
}

.adminRow{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px;
  border-radius: var(--radiusSm);
  border: 1px solid rgba(255,255,255,0.06);
  background: rgba(10,12,14,0.40);
}

.leftGroup{ display:flex; align-items:center; gap: 10px; flex-wrap:wrap; }

.fieldLabel{ font-size: 12px; color: var(--muted); }

input[type="time"],
input[type="datetime-local"],
input[type="text"]{
  background: rgba(10,12,14,0.55);
  color: var(--text);
  border: 1px solid var(--border);
  padding: 10px 10px;
  border-radius: 12px;
  outline:none;
  transition: .18s ease;
  font-size: 13px;
}
input:focus{ border-color: rgba(0,255,156,0.42); box-shadow: var(--ring); }

.btn{
  border:none;
  cursor:pointer;
  border-radius: 14px;
  padding: 10px 12px;
  font-weight: 800;
  letter-spacing: 0.2px;
  transition: transform .16s ease, filter .16s ease;
}

.btnPrimary{
  border: 1px solid rgba(0,255,156,0.40);
  background: linear-gradient(135deg, rgba(0,255,156,0.95), rgba(0,204,255,0.65));
  color: #051012;
  box-shadow: 0 14px 30px rgba(0,255,156,0.10);
}
.btnPrimary:hover{ transform: translateY(-1px); filter: brightness(1.02); }
.btnPrimary:active{ transform: translateY(0px) scale(0.99); }

.btnGhost{
  border: 1px solid var(--borderStrong);
  background: rgba(255,255,255,0.04);
  color: rgba(234,247,241,0.90);
}
.btnGhost:hover{ background: rgba(255,255,255,0.06); transform: translateY(-1px); }
.btnGhost:active{ transform: translateY(0px) scale(0.99); }

.stateChip{
  display:inline-flex;
  align-items:center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  letter-spacing: 0.25px;
  border: 1px solid rgba(255,255,255,0.10);
  background: rgba(255,255,255,0.03);
  color: rgba(234,247,241,0.78);
}
.stateChip.good{ border-color: rgba(0,255,156,0.22); background: rgba(0,255,156,0.06); color: rgba(234,247,241,0.92); }
.stateChip.bad{ border-color: rgba(255,90,90,0.25); background: rgba(255,90,90,0.08); color: rgba(255,170,170,0.92); }

.stateChip .dot{ width:8px; height:8px; border-radius:999px; background: rgba(234,247,241,0.35); }
.stateChip.good .dot{ background: var(--green); }
.stateChip.bad .dot{ background: var(--red); }

/* console area */
.consoleShell{
  margin-top: 14px;
  border-radius: var(--radius);
  border: 1px solid var(--border);
  background: var(--panel);
  box-shadow: var(--shadow);
  overflow:hidden;
}

.consoleToolbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px 12px;
  background: rgba(10,12,14,0.55);
  border-bottom: 1px solid rgba(255,255,255,0.06);
  color: var(--muted);
  font-size: 12px;
}

.console{
  height: min(52vh, 520px);
  padding: 14px;
  overflow-y:auto;
  background: #060708;
  border-top: 1px solid rgba(255,255,255,0.06);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  line-height: 1.35;
}

.consoleLine{
  white-space: pre-wrap;
  word-break: break-word;
}

/* console line entrance */
.consoleLine.new{
  animation: lineIn .18s ease forwards;
}
@keyframes lineIn{ from{ opacity:0; transform: translateY(2px);} to{ opacity:1; transform: translateY(0);} }

.inputArea{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  background: rgba(10,12,14,0.55);
  border-top: 1px solid rgba(255,255,255,0.06);
}

.prompt{
  color: rgba(234,247,241,0.70);
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-weight: 800;
}

.cmdInput{
  flex:1;
  background: rgba(10,12,14,0.55);
  border: 1px solid rgba(255,255,255,0.08);
  border-radius: 14px;
  padding: 12px 12px;
  outline:none;
  color: var(--text);
  font-size: 14px;
}
.cmdInput:focus{ border-color: rgba(0,255,156,0.42); box-shadow: var(--ring); }

/* bottom controls */
.controls{
  margin-top: 14px;
  display:flex;
  gap: 10px;
  flex-wrap:wrap;
  justify-content:flex-end;
}

/* confirm modal */
#confirmOverlay{
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
  transition: opacity 0.2s ease;
  z-index: 9999;
}
#confirmOverlay.active{
  opacity: 1;
  visibility: visible;
  pointer-events: auto;
}
#confirmCard{
  background: rgba(14, 17, 20, 0.92);
  border: 1px solid rgba(0,255,156,0.35);
  border-radius: 18px;
  max-width: 460px;
  width: 100%;
  padding: 20px 18px;
  box-shadow: 0 0 30px rgba(0, 255, 156, 0.18);
  transform: scale(0.92);
  opacity: 1;
}
#confirmOverlay.active #confirmCard{ animation: popupIn 0.24s ease forwards; }
@keyframes popupIn{ from{ transform: scale(0.92); opacity: 0; } to{ transform: scale(1); opacity: 1; } }
#confirmTitle{ margin: 0 0 6px 0; font-size: 18px; }
#confirmMessage{ margin: 0 0 16px 0; color: rgba(234,247,241,0.85); }
.confirmActions{ display:flex; justify-content:flex-end; gap: 10px; }

/* ===== 3-line menu ===== */
.menu{ position:relative; }
.menuBtn{
  width: 42px; height: 42px;
  border-radius: 14px;
  border: 1px solid var(--borderStrong);
  background: rgba(255,255,255,0.04);
  color: rgba(234,247,241,0.90);
  display:grid;
  place-items:center;
  cursor:pointer;
  transition: transform .16s ease, background .16s ease;
}
.menuBtn:hover{ background: rgba(255,255,255,0.06); transform: translateY(-1px); }
.menuBtn:active{ transform: translateY(0px) scale(0.99); }
.menuLines{ display:flex; flex-direction:column; gap: 5px; }
.menuLines span{ width: 18px; height: 2px; border-radius: 999px; background: rgba(234,247,241,0.78); }

.menuPanel{
  position:absolute;
  right: 0;
  top: calc(100% + 10px);
  min-width: 210px;
  border-radius: 16px;
  border: 1px solid var(--border);
  background: rgba(14, 17, 20, 0.92);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 24px 80px rgba(0,0,0,.55);
  padding: 8px;
  opacity: 0;
  transform: translateY(-6px) scale(0.98);
  pointer-events:none;
  transition: .16s ease;
  z-index: 50;
}
.menuPanel.open{
  opacity: 1;
  transform: translateY(0) scale(1);
  pointer-events:auto;
}

.menuItem{
  width: 100%;
  text-align:left;
  border: 1px solid transparent;
  background: rgba(255,255,255,0.03);
  color: rgba(234,247,241,0.92);
  padding: 10px 10px;
  border-radius: 12px;
  cursor:pointer;
  font-weight: 700;
  font-size: 12px;
  letter-spacing: 0.2px;
  transition: .14s ease;
}
.menuItem:hover{ background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.08); }
.menuItem.active{ border-color: rgba(0,255,156,0.22); background: rgba(0,255,156,0.06); }
.menuItem.danger{ border-color: rgba(255,90,90,0.20); background: rgba(255,90,90,0.08); }

.menuSep{ height:1px; margin: 8px 6px; background: rgba(255,255,255,0.08); }

/* ===== Tabs ===== */
.tab{ display:block; }
.tab.hidden{ display:none; }

/* Hardware grid */
.hardwareGrid{
  margin-top: 14px;
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
@media (max-width: 900px){
  .hardwareGrid{ grid-template-columns: 1fr; }
}

.hwRow{ display:flex; align-items:baseline; justify-content:space-between; gap: 10px; }
.hwName{ color: var(--muted); font-size: 12px; }
.hwValue{ font-weight: 800; }
.hwBar{ margin-top: 8px; height: 12px; border-radius: 999px; background: rgba(255,255,255,0.06); overflow:hidden; border: 1px solid rgba(255,255,255,0.08); }
.hwFill{ height:100%; width:0%; border-radius: 999px; background: linear-gradient(90deg, rgba(0,255,156,0.95), rgba(0,204,255,0.65)); transition: width .35s ease; }

/* responsive */
@media (max-width: 1080px){
  .statusPanel{ grid-template-columns: 1fr 1fr 1fr; }
  .infoBar{ grid-template-columns: 1fr; }
}
@media (max-width: 720px){
  .statusPanel{ grid-template-columns: 1fr 1fr; }
  .header{ position:relative; top:auto; }
  .controls{ justify-content:stretch; }
  .controls .btn{ flex:1; }
}
@media (prefers-reduced-motion: reduce){
  .grid, .blob, .consoleLine.new{ animation:none !important; }
}

/* utility */
.hidden{ display:none; }
</style>
</head>
<body>
  <div class="grid" aria-hidden="true"></div>
  <div class="blob a" aria-hidden="true"></div>
  <div class="blob b" aria-hidden="true"></div>
  <div class="blob c" aria-hidden="true"></div>

  <div class="container">
    <header class="header">
      <div class="brand">
        <img src="logo.png" alt="Minecraft Server Manager logo" class="header-logo" />
        <div class="titleWrap">
          <h1 class="title">Minecraft Server Manager</h1>
          <p class="subtitle">Admin Panel • Live Console • Rules & Control</p>
        </div>
      </div>

      <div class="headerRight">
        <div class="pill" id="pillServer">
          <span class="dot" aria-hidden="true"></span>
          <span>Server:</span>
          <strong id="serverStatus">UNKNOWN</strong>
        </div>
        <div class="pill" id="pillPc">
          <span class="dot" aria-hidden="true"></span>
          <span>PC:</span>
          <strong id="pcStatus">UNKNOWN</strong>
        </div>
        <div class="pill">
          <span class="dot" aria-hidden="true"></span>
          <span>Time:</span>
          <strong id="currentTime">--:--:--</strong>
        </div>

        <!-- 3-line dropdown menu -->
        <div class="menu">
          <button class="menuBtn" id="menuBtn" type="button" aria-haspopup="menu" aria-expanded="false" title="Menu">
            <span class="menuLines" aria-hidden="true">
              <span></span><span></span><span></span>
            </span>
          </button>
          <div class="menuPanel" id="menuPanel" role="menu" aria-label="Navigation">
            <button class="menuItem" role="menuitem" type="button" onclick="showTab('home')">Home</button>
            <button class="menuItem" role="menuitem" type="button" onclick="showTab('hardware')">Hardware Status</button>
            <div class="menuSep"></div>
            <button class="menuItem danger" role="menuitem" type="button" onclick="logout()">Logout</button>
          </div>
        </div>
      </div>
    </header>

    <!-- HOME TAB (default) -->
    <section id="tabHome" class="tab" aria-label="Home">
      <!-- NEW INFO BAR: Display status + PC status toggles -->
      <section class="infoBar" aria-label="Quick controls">
        <div class="card">
          <div class="cardInner">
            <div class="cardTop">
              <div>
                <div class="cardTitle">Display Status</div>
                <div id="displayStateText" class="cardValue valueOffline">OFF</div>
                <div class="small">UI display indicator (sync this with your backend if needed)</div>
              </div>
              <div class="switch">
                <div id="displayToggle" class="toggle" role="switch" aria-checked="false" tabindex="0" title="Toggle display status"></div>
                <div class="toggleLabel" id="displayToggleLabel">OFF</div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="cardInner">
            <div class="cardTop">
              <div>
                <div class="cardTitle">PC Status Control</div>
                <div id="pcControlText" class="cardValue valueWarn">--</div>
                <div class="small">Sends a command to your API (Wake / Shutdown)</div>
              </div>
              <div class="switch">
                <div id="pcToggle" class="toggle" role="switch" aria-checked="false" tabindex="0" title="Toggle PC power"></div>
                <div class="toggleLabel" id="pcToggleLabel">OFF</div>
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <div class="cardInner">
            <div class="cardTop">
              <div>
                <div class="cardTitle">Server Control</div>
                <div id="serverControlText" class="cardValue valueWarn">--</div>
                <div class="small">Start/Stop server safely (with confirmation)</div>
              </div>
              <div class="switch">
                <div id="serverToggle" class="toggle" role="switch" aria-checked="false" tabindex="0" title="Toggle server"></div>
                <div class="toggleLabel" id="serverToggleLabel">OFF</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      
    </section>

    <!-- HARDWARE TAB -->
    <section id="tabHardware" class="tab hidden" aria-label="Hardware Status">
      <section class="adminPanel" aria-label="Hardware status panel">
        <div class="adminRow">
          <div class="leftGroup" style="justify-content:space-between; width:100%;">
            <div>
              <div class="fieldLabel">Hardware Status</div>
              <div class="small">Pulled from <code style="color:rgba(234,247,241,0.85)">/hardware</code>. If your API doesn't have it yet, add it and this page will work.</div>
            </div>
            <button class="btn btnGhost" onclick="refreshHardware()">Refresh</button>
          </div>
        </div>

        <div class="hardwareGrid">
          <div class="card"><div class="cardInner">
            <div class="hwRow"><div class="hwName">CPU</div><div class="hwValue" id="cpuName">--</div></div>
            <div class="small" id="cpuUsageText">Usage: --%</div>
            <div class="hwBar"><div class="hwFill" id="cpuFill"></div></div>
          </div></div>

          <div class="card"><div class="cardInner">
            <div class="hwRow"><div class="hwName">GPU</div><div class="hwValue" id="gpuName">--</div></div>
            <div class="small" id="gpuUsageText">Usage: --%</div>
            <div class="hwBar"><div class="hwFill" id="gpuFill"></div></div>
          </div></div>

          <div class="card"><div class="cardInner">
            <div class="hwRow"><div class="hwName">RAM</div><div class="hwValue" id="pcRamText">--</div></div>
            <div class="small" id="pcRamUsageText">Usage: --%</div>
            <div class="hwBar"><div class="hwFill" id="pcRamFill"></div></div>
          </div></div>

          <div class="card"><div class="cardInner">
            <div class="hwRow"><div class="hwName">Storage</div><div class="hwValue" id="storageText">--</div></div>
            <div class="small" id="storageUsageText">Usage: --%</div>
            <div class="hwBar"><div class="hwFill" id="storageFill"></div></div>
          </div></div>
        </div>
      </section>
    </section>

    <!-- STATUS PANEL -->
    <section class="statusPanel" aria-label="Status">
      <div class="stat">
        <div class="statInner">
          <div class="statLabel">Players Online</div>
          <div class="statValue" id="playerCount">0 / 20</div>
          <div class="playerNames" id="playerNames"><span class="playerEmpty">No players</span></div>
        </div>
      </div>

      <div class="stat">
        <div class="statInner">
          <div class="statLabel">RAM Usage</div>
          <div class="statValue" id="ramText">0MB / 4096MB</div>
          <div class="ramBar"><div id="ramFill" class="ramFill"></div></div>
        </div>
      </div>

      <div class="stat">
        <div class="statInner">
          <div class="statLabel">Maintenance</div>
          <div class="statValue" id="maintenanceText">None</div>
          <div class="small" id="maintenanceSub">No maintenance scheduled</div>
        </div>
      </div>

      <div class="stat">
        <div class="statInner">
          <div class="statLabel">User Commands</div>
          <div class="statValue" id="cmdPermText">--</div>
          <div class="small">Allow/Block user console access</div>
        </div>
      </div>

      <div class="stat">
        <div class="statInner">
          <div class="statLabel">Console</div>
          <div class="statValue" id="consoleHealth">Live</div>
          <div class="small">Autoscroll + buffering enabled</div>
        </div>
      </div>
    </section>

    <!-- ADMIN SETTINGS -->
    <section class="adminPanel" aria-label="Admin settings">
      <div class="adminRow">
        <div class="leftGroup">
          <span class="fieldLabel" for="scheduleTime">Schedule Maintenance Until</span>
          <input type="datetime-local" id="scheduleTime" aria-describedby="scheduleInfo" />
          <button class="btn btnPrimary" onclick="setSchedule()">Set</button>
          <span id="scheduleInfo" class="fieldLabel" aria-live="polite"></span>
        </div>
      </div>

      <div class="adminRow" style="margin-top:10px;">
        <div class="leftGroup">
          <span class="fieldLabel">User Command Permission</span>
          <button id="commandApproveBtn" class="btn btnGhost" onclick="toggleCommandApprove()" aria-pressed="true">Loading…</button>
          <span id="commandApproveInfo" class="stateChip" aria-live="polite"><span class="dot" aria-hidden="true"></span>Loading</span>
        </div>
      </div>
    </section>

    <!-- CONSOLE -->
    <section class="consoleShell" aria-label="Console">
      <div class="consoleToolbar">
        <span id="autoScrollState">Autoscroll: ON</span>
        <div style="display:flex; gap:10px; align-items:center;">
          <button class="btn btnGhost" id="toggleAutoscrollBtn" onclick="toggleAutoscroll()">Pause Autoscroll</button>
          <button class="btn btnGhost" onclick="clearConsole()">Clear</button>
        </div>
      </div>

      <div id="console" class="console">
        <div class="consoleLine">[Admin] Control panel ready.</div>
      </div>

      <div class="inputArea">
        <span class="prompt">&gt;</span>
        <input id="cmdInput" class="cmdInput" type="text" placeholder="Enter command…" aria-label="Console command" onkeydown="handleCommand(event)" />
        <button class="btn btnPrimary" onclick="sendQuickCommand()">Send</button>
      </div>
    </section>

    <div class="controls">
      <button class="btn btnPrimary" onclick="startServer()">Start Server</button>
      <button class="btn btnGhost" onclick="stopServer()">Stop Server</button>
    </div>
  </div>

  <!-- CONFIRM -->
  <div id="confirmOverlay" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMessage">
    <div id="confirmCard">
      <h3 id="confirmTitle">Confirm Action</h3>
      <p id="confirmMessage">Are you sure?</p>
      <div class="confirmActions">
        <button id="confirmCancelBtn" class="btn btnGhost">Cancel</button>
        <button id="confirmOkBtn" class="btn btnPrimary">OK</button>
      </div>
    </div>
  </div>

<script>
// ============================
// ACCESS CONTROL
// ============================
const storedRole = sessionStorage.getItem("role") || localStorage.getItem("role");
const storedUser = sessionStorage.getItem("username") || localStorage.getItem("username");
if (storedRole !== "admin") {
  window.location.href = "index.html";
} else {
  if (!sessionStorage.getItem("role")) sessionStorage.setItem("role", storedRole);
  if (storedUser && !sessionStorage.getItem("username")) sessionStorage.setItem("username", storedUser);
}

// ============================
// CONFIG
// ============================
const API_BASE = "https://mc-api-o0jz.onrender.com/v1";
const MOTOR_API_BASE = "https://esp-32-f8bg.onrender.com";

// ============================
// ELEMENTS
// ============================
const consoleBox = document.getElementById("console");

// Tabs
const tabHome = document.getElementById("tabHome");
const tabHardware = document.getElementById("tabHardware");
const menuBtn = document.getElementById("menuBtn");
const menuPanel = document.getElementById("menuPanel");

// Hardware elements
const cpuNameEl = document.getElementById("cpuName");
const cpuUsageTextEl = document.getElementById("cpuUsageText");
const cpuFillEl = document.getElementById("cpuFill");

const gpuNameEl = document.getElementById("gpuName");
const gpuUsageTextEl = document.getElementById("gpuUsageText");
const gpuFillEl = document.getElementById("gpuFill");

const pcRamTextEl = document.getElementById("pcRamText");
const pcRamUsageTextEl = document.getElementById("pcRamUsageText");
const pcRamFillEl = document.getElementById("pcRamFill");

const storageTextEl = document.getElementById("storageText");
const storageUsageTextEl = document.getElementById("storageUsageText");
const storageFillEl = document.getElementById("storageFill");

const playerCount = document.getElementById("playerCount");
const playerNames = document.getElementById("playerNames");
const ramText = document.getElementById("ramText");
const ramFill = document.getElementById("ramFill");
const pcStatus = document.getElementById("pcStatus");
const serverStatus = document.getElementById("serverStatus");
const currentTime = document.getElementById("currentTime");

const scheduleInput = document.getElementById("scheduleTime");
const scheduleInfo = document.getElementById("scheduleInfo");
const commandApproveBtn = document.getElementById("commandApproveBtn");
const commandApproveInfo = document.getElementById("commandApproveInfo");

const maintenanceText = document.getElementById("maintenanceText");
const maintenanceSub = document.getElementById("maintenanceSub");
const cmdPermText = document.getElementById("cmdPermText");

const autoScrollState = document.getElementById("autoScrollState");
const toggleAutoscrollBtn = document.getElementById("toggleAutoscrollBtn");

const pillServer = document.getElementById("pillServer");
const pillPc = document.getElementById("pillPc");

// NEW TOGGLES
const displayToggle = document.getElementById("displayToggle");
const displayToggleLabel = document.getElementById("displayToggleLabel");
const displayStateText = document.getElementById("displayStateText");

const pcToggle = document.getElementById("pcToggle");
const pcToggleLabel = document.getElementById("pcToggleLabel");
const pcControlText = document.getElementById("pcControlText");

const serverToggle = document.getElementById("serverToggle");
const serverToggleLabel = document.getElementById("serverToggleLabel");
const serverControlText = document.getElementById("serverControlText");

// CONFIRM
const confirmOverlay = document.getElementById("confirmOverlay");
const confirmTitle = document.getElementById("confirmTitle");
const confirmMessage = document.getElementById("confirmMessage");
const confirmCancelBtn = document.getElementById("confirmCancelBtn");
const confirmOkBtn = document.getElementById("confirmOkBtn");

// ============================
// STATE
// ============================
let scheduledTime = null;
let hardwareInFlight = false;
let lastHardware = null;
let hardwareTimerId = null;
let consoleOffset = 0;
let ignoreInitialConsoleBatch = true;
let consoleClearedForOffline = false;
let commandApprove = true;
let autoScrollEnabled = true;
let consoleLineCount = 1;
const maxConsoleLines = 900;
let consoleFlushTimer = null;
let pendingConsoleLines = [];
let pollConsoleInFlight = false;
let refreshStatusInFlight = false;
let syncSettingsInFlight = false;
let confirmResolver = null;

// NEW STATE
let displayOn = false; // populated from motor API heartbeat
let desiredPcPower = false;
let desiredMonitorPower = false;
let lastHeartbeatMs = 0;
const heartbeatFreshMs = 120000;
let lastKnownPcOnline = false;
let lastKnownServerRunning = false;

let statusTimerId = null;
let consoleTimerId = null;
let settingsTimerId = null;

// ============================
// HELPERS
// ============================
function print(text) { queueConsoleLines([text]); }

function queueConsoleLines(lines) {
  if (!Array.isArray(lines) || lines.length === 0) return;
  for (const line of lines) pendingConsoleLines.push(String(line ?? ""));
  if (consoleFlushTimer === null) consoleFlushTimer = setTimeout(flushConsoleLines, 60);
}

function flushConsoleLines() {
  if (pendingConsoleLines.length === 0) { consoleFlushTimer = null; return; }

  const fragment = document.createDocumentFragment();
  for (const text of pendingConsoleLines) {
    const div = document.createElement("div");
    div.className = "consoleLine new";
    div.textContent = text;
    fragment.appendChild(div);
    consoleLineCount += 1;
  }
  pendingConsoleLines = [];

  consoleBox.appendChild(fragment);
  while (consoleLineCount > maxConsoleLines && consoleBox.firstElementChild) {
    consoleBox.removeChild(consoleBox.firstElementChild);
    consoleLineCount -= 1;
  }

  if (autoScrollEnabled) consoleBox.scrollTop = consoleBox.scrollHeight;
  consoleFlushTimer = null;
}

function renderPlayerNames(players) {
  playerNames.innerHTML = "";
  if (!players || players.length === 0) {
    const empty = document.createElement("span");
    empty.className = "playerEmpty";
    empty.textContent = "No players";
    playerNames.appendChild(empty);
    return;
  }
  for (const name of players) {
    const cleaned = cleanPlayerName(name);
    if (!cleaned) continue;
    const chip = document.createElement("span");
    chip.className = "playerChip";
    chip.textContent = cleaned;
    playerNames.appendChild(chip);
  }
}

function cleanPlayerName(name) {
  let s = String(name || "").trim();
  s = s.replace(/§./g, "");
  s = s.replace(/&[0-9A-FK-ORa-fk-or]/g, "");
  s = s.replace(/\?{1,2}[0-9A-FK-ORa-fk-or]/g, "");
  const m = s.match(/[A-Za-z0-9_]{1,16}/);
  return m ? m[0] : "";
}

function toLocalTimeText(value) {
  if (!value) return "";
  const dt = new Date(value);
  if (isNaN(dt.getTime())) return String(value);
  return dt.toLocaleString([], { year: "numeric", month: "short", day: "2-digit", hour: "2-digit", minute: "2-digit" });
}

function normalizeScheduleValue(value) {
  if (!value) return "";
  const trimmed = String(value).trim();
  if (/^\d{2}:\d{2}$/.test(trimmed)) {
    const now = new Date();
    const yyyy = String(now.getFullYear());
    const mm = String(now.getMonth() + 1).padStart(2, "0");
    const dd = String(now.getDate()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd}T${trimmed}`;
  }
  return trimmed;
}

async function apiRequest(path, options = {}) {
  const fetchOptions = { cache: "no-store", ...options };
  const sep = path.includes("?") ? "&" : "?";
  const res = await fetch(`${API_BASE}${path}${sep}_t=${Date.now()}`, fetchOptions);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.status === 204 ? {} : res.json();
}

async function motorRequest(path, options = {}) {
  const fetchOptions = { cache: "no-store", ...options };
  const sep = path.includes("?") ? "&" : "?";
  const res = await fetch(`${MOTOR_API_BASE}${path}${sep}_t=${Date.now()}`, fetchOptions);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  return res.status === 204 ? {} : res.json();
}

function setPillState(pillEl, state) {
  pillEl.classList.remove("good", "bad", "warn");
  if (state === "good") pillEl.classList.add("good");
  if (state === "bad") pillEl.classList.add("bad");
  if (state === "warn") pillEl.classList.add("warn");
}

function updateAutoscrollUI() {
  autoScrollState.textContent = `Autoscroll: ${autoScrollEnabled ? "ON" : "OFF"}`;
  toggleAutoscrollBtn.textContent = autoScrollEnabled ? "Pause Autoscroll" : "Resume Autoscroll";
}

function toggleAutoscroll() {
  autoScrollEnabled = !autoScrollEnabled;
  if (autoScrollEnabled) consoleBox.scrollTop = consoleBox.scrollHeight;
  updateAutoscrollUI();
}

function isNearBottom() {
  const threshold = 24;
  return consoleBox.scrollHeight - consoleBox.scrollTop - consoleBox.clientHeight < threshold;
}

function showConfirm(title, message) {
  return new Promise((resolve) => {
    confirmResolver = resolve;
    confirmTitle.textContent = title || "Confirm";
    confirmMessage.textContent = message || "Are you sure?";
    confirmOverlay.classList.add("active");
    confirmOkBtn.focus();
  });
}

function closeConfirm(result) {
  confirmOverlay.classList.remove("active");
  if (confirmResolver) {
    const r = confirmResolver;
    confirmResolver = null;
    r(Boolean(result));
  }
}

confirmOkBtn.addEventListener("click", () => closeConfirm(true));
confirmCancelBtn.addEventListener("click", () => closeConfirm(false));
confirmOverlay.addEventListener("click", (e) => { if (e.target === confirmOverlay) closeConfirm(false); });
document.addEventListener("keydown", (e) => {
  if (!confirmOverlay.classList.contains("active")) return;
  if (e.key === "Escape") closeConfirm(false);
  if (e.key === "Enter") closeConfirm(true);
});

consoleBox.addEventListener("scroll", () => {
  if (autoScrollEnabled && !isNearBottom()) {
    autoScrollEnabled = false;
    updateAutoscrollUI();
  } else if (!autoScrollEnabled && isNearBottom()) {
    autoScrollEnabled = true;
    updateAutoscrollUI();
  }
});

// ============================
// NAV MENU + TABS
// ============================
function closeMenu(){
  if (!menuPanel) return;
  menuPanel.classList.remove("open");
  menuBtn?.setAttribute("aria-expanded", "false");
}
function openMenu(){
  if (!menuPanel) return;
  menuPanel.classList.add("open");
  menuBtn?.setAttribute("aria-expanded", "true");
}
function toggleMenu(){
  if (!menuPanel) return;
  const open = menuPanel.classList.contains("open");
  open ? closeMenu() : openMenu();
}
menuBtn?.addEventListener("click", (e) => { e.stopPropagation(); toggleMenu(); });
document.addEventListener("click", () => closeMenu());
document.addEventListener("keydown", (e) => { if (e.key === "Escape") closeMenu(); });

function setMenuActive(which){
  if (!menuPanel) return;
  const items = menuPanel.querySelectorAll(".menuItem");
  items.forEach(btn => btn.classList.remove("active"));
  const map = { home: 0, hardware: 1 };
  const idx = map[which];
  if (typeof idx === "number" && items[idx]) items[idx].classList.add("active");
}

function showTab(which){
  if (which === "hardware"){
    tabHardware?.classList.remove("hidden");
    tabHome?.classList.add("hidden");
    setMenuActive("hardware");
    // refresh when entering
    refreshHardware();
  } else {
    tabHome?.classList.remove("hidden");
    tabHardware?.classList.add("hidden");
    setMenuActive("home");
  }
  closeMenu();
}

// default tab
showTab("home");

// ============================
// HARDWARE STATUS
// ============================
function setBar(fillEl, pct){
  const p = Math.max(0, Math.min(100, Number(pct || 0)));
  if (fillEl) fillEl.style.width = `${p}%`;
}

function renderHardware(hw){
  if (!hw) return;

  // Expected shape from API:
  // hw = {
  //   cpu: { name: "...", usagePercent: 35 },
  //   gpu: { name: "...", usagePercent: 12 },
  //   ram: { usedMb: 4200, totalMb: 8192, usagePercent: 51 },
  //   storage: { usedGb: 120, totalGb: 512, usagePercent: 23 }
  // }

  const cpuName = hw.cpu?.name ?? "--";
  const cpuPct = Number(hw.cpu?.usagePercent ?? 0);
  cpuNameEl && (cpuNameEl.textContent = cpuName);
  cpuUsageTextEl && (cpuUsageTextEl.textContent = `Usage: ${isFinite(cpuPct) ? cpuPct : 0}%`);
  setBar(cpuFillEl, cpuPct);

  const gpuName = hw.gpu?.name ?? "--";
  const gpuPct = Number(hw.gpu?.usagePercent ?? 0);
  gpuNameEl && (gpuNameEl.textContent = gpuName);
  gpuUsageTextEl && (gpuUsageTextEl.textContent = `Usage: ${isFinite(gpuPct) ? gpuPct : 0}%`);
  setBar(gpuFillEl, gpuPct);

  const ramUsed = hw.ram?.usedMb;
  const ramTotal = hw.ram?.totalMb;
  const ramPct = Number(hw.ram?.usagePercent ?? (ramUsed && ramTotal ? (ramUsed/ramTotal)*100 : 0));
  if (pcRamTextEl){
    if (ramUsed != null && ramTotal != null) {
      const usedGb = ramUsed / 1024;
      const totalGb = ramTotal / 1024;
      pcRamTextEl.textContent = `${usedGb.toFixed(1)}GB / ${totalGb.toFixed(1)}GB`;
    } else {
      pcRamTextEl.textContent = "--";
    }
  }
  pcRamUsageTextEl && (pcRamUsageTextEl.textContent = `Usage: ${isFinite(ramPct) ? Math.round(ramPct) : 0}%`);
  setBar(pcRamFillEl, ramPct);

  const stUsed = hw.storage?.usedGb;
  const stTotal = hw.storage?.totalGb;
  const stPct = Number(hw.storage?.usagePercent ?? (stUsed && stTotal ? (stUsed/stTotal)*100 : 0));
  if (storageTextEl){
    if (stUsed != null && stTotal != null) storageTextEl.textContent = `${Number(stUsed).toFixed(0)}GB / ${Number(stTotal).toFixed(0)}GB`;
    else storageTextEl.textContent = "--";
  }
  storageUsageTextEl && (storageUsageTextEl.textContent = `Usage: ${isFinite(stPct) ? Math.round(stPct) : 0}%`);
  setBar(storageFillEl, stPct);
}

async function refreshHardware(){
  if (hardwareInFlight) return;
  hardwareInFlight = true;
  try{
    const data = await apiRequest("/hardware");
    // Expected: { ok:true, hardware:{...} } or { hardware:{...} }
    const hw = data.hardware || data.status || data;
    lastHardware = hw;
    renderHardware(hw);
  } catch {
    // silent
    // If we have previous, keep showing it
    if (lastHardware) renderHardware(lastHardware);
  } finally {
    hardwareInFlight = false;
  }
}

// ============================
// NEW: TOGGLES (DISPLAY / PC / SERVER)
// ============================
function setToggle(el, on) {
  el.classList.toggle("on", !!on);
  el.setAttribute("aria-checked", String(!!on));
}

function renderDisplayToggle() {
  setToggle(displayToggle, desiredMonitorPower);
  displayToggleLabel.textContent = desiredMonitorPower ? "ON" : "OFF";

  const fresh = lastHeartbeatMs > 0 && (Date.now() - lastHeartbeatMs) <= heartbeatFreshMs;
  const showOn = desiredMonitorPower || (fresh && displayOn);
  if (fresh || desiredMonitorPower || !desiredMonitorPower) {
    displayStateText.textContent = showOn ? "ON" : "OFF";
    displayStateText.classList.toggle("valueOnline", showOn);
    displayStateText.classList.toggle("valueOffline", !showOn);
    displayStateText.classList.remove("valueWarn");
  }
}

async function onDisplayToggle() {
  // Send command to motor API, then refresh real state from heartbeat.
  const wantOn = !desiredMonitorPower;
  desiredMonitorPower = wantOn;
  renderDisplayToggle();
  try {
    await motorRequest(wantOn ? "/monitor_on" : "/monitor_off");
    print(`[UI] Monitor command sent: ${wantOn ? "ON" : "OFF"}`);
  } catch {
    print("[Error] Failed to send monitor command.");
  } finally {
    await refreshDisplayState();
  }
}

function renderPcToggle() {
  // Toggle reflects desired power state; status text shows online/offline
  setToggle(pcToggle, desiredPcPower);
  pcToggleLabel.textContent = desiredPcPower ? "ON" : "OFF";
  const showOnline = desiredPcPower;
  pcControlText.textContent = showOnline ? "ONLINE" : "OFFLINE";
  pcControlText.className = `cardValue ${showOnline ? "valueOnline" : "valueOffline"}`;
}

async function onPcToggle() {
  // If currently online -> request shutdown, else -> request wake
  const wantOn = !desiredPcPower;
  const ok = await showConfirm(
    wantOn ? "Turn PC ON" : "Turn PC OFF",
    wantOn ? "Send wake command to the PC?" : "Send shutdown command to the PC?"
  );
  if (!ok) return;

  try {
    desiredPcPower = wantOn;
    renderPcToggle();
    await motorRequest(wantOn ? "/pc_on" : "/pc_off");
    print(`[Admin] PC command sent: ${wantOn ? "pc_on" : "pc_off"}`);

    if (!wantOn) {
      try {
        const data = await apiRequest("/commands", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ role: "admin", requestedBy: "admin", command: "shutdown_pc" })
        });
        print(data.ok ? "[Queue] PC shutdown countdown requested." : "[Error] Failed to queue PC shutdown.");
      } catch {
        print("[Error] Failed to queue PC shutdown.");
      }
    }
  } catch {
    print("[Error] PC command request failed.");
  } finally {
    await refreshDisplayState();
  }
}

function renderServerToggle() {
  setToggle(serverToggle, lastKnownServerRunning);
  serverToggleLabel.textContent = lastKnownServerRunning ? "ON" : "OFF";
  serverControlText.textContent = lastKnownServerRunning ? "RUNNING" : "STOPPED";
  serverControlText.className = `cardValue ${lastKnownServerRunning ? "valueOnline" : "valueOffline"}`;
}

async function onServerToggle() {
  const wantOn = !lastKnownServerRunning;
  if (wantOn) await startServer();
  else await stopServer();
}

function hookToggle(el, handler){
  el.addEventListener("click", handler);
  el.addEventListener("keydown", (e) => {
    if (e.key === "Enter" || e.key === " ") { e.preventDefault(); handler(); }
  });
}

hookToggle(displayToggle, onDisplayToggle);
hookToggle(serverToggle, onServerToggle);
hookToggle(pcToggle, onPcToggle);

// ============================
// RULES SETTINGS
// ============================
function renderCommandApprove() {
  commandApproveBtn.textContent = commandApprove ? "TURN OFF USER COMMANDS" : "TURN ON USER COMMANDS";
  commandApproveBtn.setAttribute("aria-pressed", String(commandApprove));

  const ok = commandApprove;
  commandApproveInfo.classList.toggle("good", ok);
  commandApproveInfo.classList.toggle("bad", !ok);
  commandApproveInfo.innerHTML = `<span class="dot" aria-hidden="true"></span>${ok ? "ALLOWED" : "BLOCKED"}`;
  cmdPermText.textContent = ok ? "ALLOWED" : "BLOCKED";
}

async function syncAdminSettings() {
  if (syncSettingsInFlight) return;
  syncSettingsInFlight = true;
  try {
    const data = await apiRequest("/rules");
    const rules = data.rules || {};

    commandApprove = rules.commandApprove !== false;
    renderCommandApprove();

    const dbTime = (rules.maintenanceUntil || "").toString();
    if (dbTime && dbTime.trim()) {
      scheduledTime = dbTime.trim();
      const normalized = normalizeScheduleValue(scheduledTime);
      scheduleInput.value = normalized;
      const t = toLocalTimeText(normalized);
      scheduleInfo.textContent = `Maintenance until ${t}`;
      maintenanceText.textContent = "Active";
      maintenanceSub.textContent = `Until ${t}`;
    } else {
      scheduledTime = null;
      scheduleInput.value = "";
      scheduleInfo.textContent = "No maintenance scheduled";
      maintenanceText.textContent = "None";
      maintenanceSub.textContent = "No maintenance scheduled";
    }
  } catch {
    scheduleInfo.textContent = "Rules sync failed";
  } finally {
    syncSettingsInFlight = false;
  }
}

async function toggleCommandApprove() {
  try {
    commandApprove = !commandApprove;
    await apiRequest("/rules", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ commandApprove })
    });
    renderCommandApprove();
    print(`[Admin] command_approve set to ${commandApprove}`);
  } catch {
    print("[Error] Failed to update command_approve.");
  }
}

async function setSchedule() {
  const value = scheduleInput.value.trim();
  if (value && isNaN(Date.parse(value))) {
    scheduleInfo.textContent = "Invalid date/time";
    print("[Error] Invalid maintenance date/time.");
    return;
  }
  try {
    await apiRequest("/rules", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ maintenanceUntil: value || "" })
    });
    scheduledTime = value || null;
    const localText = value ? toLocalTimeText(value) : "";
    scheduleInfo.textContent = value ? `Maintenance until ${localText}` : "Maintenance cleared";
    print(value ? `[Admin] Maintenance set until ${localText}` : "[Admin] Maintenance cleared");
  } catch {
    print("[Error] Failed to update maintenance time.");
  }
}

// ============================
// STATUS
// ============================
function applyStatus(status) {
  const maxPlayers = Number(status.maxPlayers || 0);
  const online = Number(status.onlinePlayers || 0);
  const ram = Number(status.ramUsageMb || 0);
  const players = Array.isArray(status.players) ? status.players : [];
  const ramMax = Number(status.ramMaxMb || status.ramMax || 8192);
  const updatedAt = status.updatedAtUtc || status.updatedAt || "";
  let fresh = true;
  if (updatedAt) {
    const ts = Date.parse(updatedAt);
    if (!isNaN(ts)) {
      fresh = (Date.now() - ts) <= 30000;
    }
  }

  playerCount.textContent = `${online} / ${maxPlayers || 0}`;
  renderPlayerNames(players);

  ramText.textContent = `${ram}MB / ${ramMax}MB`;
  const pct = ramMax > 0 ? Math.min(100, Math.round((ram / ramMax) * 100)) : 0;
  ramFill.style.width = `${pct}%`;

  // PC state: prefer backend signal; otherwise use freshness of status update.
  if (typeof status.pcOnline === "boolean") lastKnownPcOnline = status.pcOnline;
  else lastKnownPcOnline = fresh;
  pcStatus.textContent = lastKnownPcOnline ? "ONLINE" : "OFFLINE";
  pcStatus.style.color = "";
  setPillState(pillPc, lastKnownPcOnline ? "good" : "bad");

  // Server running
  lastKnownServerRunning = !!status.isRunning;
  if (lastKnownServerRunning) {
    serverStatus.textContent = "ONLINE";
    setPillState(pillServer, "good");
  } else {
    serverStatus.textContent = "OFFLINE";
    setPillState(pillServer, "bad");
  }

  // Auto-clear console when server is offline or status is stale.
  const shouldClearConsole = !lastKnownServerRunning;
  if (shouldClearConsole && !consoleClearedForOffline) {
    clearConsole(true);
    consoleClearedForOffline = true;
  } else if (!shouldClearConsole) {
    consoleClearedForOffline = false;
  }

  // reflect toggles
  renderPcToggle();
  renderServerToggle();
}

async function refreshStatus() {
  if (refreshStatusInFlight) return;
  refreshStatusInFlight = true;
  try {
    const data = await apiRequest("/status");
    const status = data.status || {};
    applyStatus(status);
    await refreshDisplayState();
  } catch {
    // if status fails -> PC offline
    lastKnownPcOnline = false;
    lastKnownServerRunning = false;

    pcStatus.textContent = "OFFLINE";
    serverStatus.textContent = "UNKNOWN";
    setPillState(pillPc, "bad");
    setPillState(pillServer, "warn");

    if (!consoleClearedForOffline) {
      clearConsole(true);
      consoleClearedForOffline = true;
    }

    renderPcToggle();
    renderServerToggle();
  } finally {
    refreshStatusInFlight = false;
  }
}

async function refreshDisplayState() {
  try {
    const data = await motorRequest("/state");
    const state = data.state || {};
    if (typeof state.displayOn === "boolean") displayOn = state.displayOn;
    if (typeof state.desiredPcPower === "boolean") desiredPcPower = state.desiredPcPower;
    if (typeof state.desiredMonitorPower === "boolean") desiredMonitorPower = state.desiredMonitorPower;
    if (typeof state.lastHeartbeatMs === "number") lastHeartbeatMs = state.lastHeartbeatMs;

    renderDisplayToggle();
    renderPcToggle();
  } catch {
    // silent
  }
}

// ============================
// CONSOLE POLL
// ============================
async function pollConsole() {
  if (pollConsoleInFlight) return;
  pollConsoleInFlight = true;
  try {
    const data = await apiRequest(`/console?since=${consoleOffset}`);
    if (data && data.ok && Array.isArray(data.lines)) {
      if (ignoreInitialConsoleBatch) {
        ignoreInitialConsoleBatch = false;
      } else {
        const batch = data.lines.map(item => item.text || "");
        queueConsoleLines(batch);
      }
    }
    if (data && typeof data.next === "number") consoleOffset = data.next;
  } catch {
    // silent
  } finally {
    pollConsoleInFlight = false;
  }
}

function updateClock() {
  currentTime.textContent = new Date().toLocaleTimeString();
}

// ============================
// COMMANDS
// ============================
async function handleCommand(e) {
  if (e.key !== "Enter") return;
  let cmd = e.target.value.trim();
  if (!cmd) return;
  if (cmd.startsWith("/")) cmd = cmd.slice(1).trim();

  print(`> ${cmd}`);
  e.target.value = "";

  try {
    const data = await apiRequest("/commands", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ role: "admin", requestedBy: "admin", command: cmd })
    });
    print(data.ok ? `[Queue] Command queued: ${cmd}` : "[Error] Failed to queue command.");
  } catch {
    print("[Error] Failed to send command.");
  }
}

function sendQuickCommand(){
  const input = document.getElementById("cmdInput");
  if (!input) return;
  const evt = { key: "Enter", target: input };
  handleCommand(evt);
}

async function startServer() {
  const ok = await showConfirm("Start Server", "Start the server now?");
  if (!ok) return;
  try {
    const data = await apiRequest("/commands", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ role: "admin", requestedBy: "admin", command: "start_server" })
    });
    print(data.ok ? "[Queue] Start command queued." : "[Error] Server start queue failed.");
  } catch {
    print("[Error] Failed to contact API.");
  }
}

async function stopServer() {
  const ok = await showConfirm("Stop Server", "Stop the server now? This will disconnect players.");
  if (!ok) return;
  try {
    const data = await apiRequest("/commands", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ role: "admin", requestedBy: "admin", command: "stop_server" })
    });
    print(data.ok ? "[Queue] Stop command queued." : "[Error] Server stop queue failed.");
  } catch {
    print("[Error] Failed to contact API.");
  }
}

function clearConsole(resetOffset = false){
  consoleBox.innerHTML = "";
  consoleLineCount = 0;
  if (resetOffset) {
    consoleOffset = 0;
    ignoreInitialConsoleBatch = true;
  }
  print("[Admin] Console cleared.");
}

function logout(){
  sessionStorage.removeItem("role");
  sessionStorage.removeItem("username");
  localStorage.removeItem("role");
  localStorage.removeItem("username");
  window.location.href = "index.html";
}

// ============================
// POLLING
// ============================
function startPolling() {
  if (statusTimerId) clearInterval(statusTimerId);
  if (consoleTimerId) clearInterval(consoleTimerId);
  if (settingsTimerId) clearInterval(settingsTimerId);
  if (hardwareTimerId) clearInterval(hardwareTimerId);

  const isHidden = document.hidden;
  const statusEvery = isHidden ? 5000 : 1200;
  const consoleEvery = isHidden ? 3500 : 1000;
  const settingsEvery = isHidden ? 15000 : 5000;
  const hardwareEvery = isHidden ? 15000 : 4000;

  statusTimerId = setInterval(refreshStatus, statusEvery);
  consoleTimerId = setInterval(pollConsole, consoleEvery);
  settingsTimerId = setInterval(syncAdminSettings, settingsEvery);
  hardwareTimerId = setInterval(refreshHardware, hardwareEvery);
}

// ============================
// INIT
// ============================
updateAutoscrollUI();
renderDisplayToggle();
renderPcToggle();
renderServerToggle();

refreshStatus();
pollConsole();
syncAdminSettings();
updateClock();
refreshHardware();
startPolling();
setInterval(updateClock, 1000);

document.addEventListener("visibilitychange", startPolling);
window.addEventListener("focus", () => { refreshStatus(); pollConsole(); syncAdminSettings(); });
</script>
</body>
</html>
